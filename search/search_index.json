{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Are you a Kotlin developer that wants to learn Dart, or a Dart developer that wants to learn Kotlin, with the least possible effort? Then you are in the right place!</p> <p>Important note: info boxes that does not specify if they refer to Kotlin or Dart by default are referring to Dart. for example:</p>  <p>semicolon at end of lines</p>  <p>This document is based on </p> <ul> <li>Dart version 2.18.0</li> <li>Kotlin 1.7.10</li> </ul>"},{"location":"#kotlin-to-dart-transpiler","title":"Kotlin to Dart transpiler","text":"<p>If you are interested into a tool to help porting Kotlin code to Dart try our kotlin2dart transpiler.</p>"},{"location":"#experimenting-with-code","title":"Experimenting with code","text":"<p>You can experiment with Dart code online in DartPad</p> <p>You can experiment with Kotlin code online in Kotlin Playground</p>"},{"location":"#hello-world","title":"Hello World","text":"<p>The basic Dart syntax is very similar to Java. </p> <p>Kotlin<pre><code>public fun main() { //public is optional\n    var w = \"world\"\n    print(\"Hello $w\") //output \"Hello world\"\n}\n</code></pre> Dart<pre><code>void main() {\n    var w = 'world';\n    print('Hello $w'); //output 'hello world'\n}\n</code></pre></p>  semicolon at end of lines <p>Dart requires a semicolon (;) at the end of code lines. In Kotlin they are optional</p>   single quotes for strings <p>Dart allows both single and double quotes for defining string literals. In Kotlin double quotes are required while single quotes define character literals</p>   no <code>public</code>, <code>protected</code>, <code>private</code> <p>Dart doesn\u2019t have the keywords <code>public</code>, <code>protected</code>, and <code>private</code>. If an identifier starts with an underscore (_), it\u2019s private to its library.</p>   string interpolation works the same way <p>Dart see docs. Kotlin see docs</p>   <code>var</code> works the same way <p>Dart is strongly typed with support for type inference like Kotlin </p>"},{"location":"#variables","title":"Variables","text":"<p>Kotlin<pre><code>    var a = 1               //variable, type inferred\n    var aa:Int = 1          //variable, type explicit\n\n    val b = 2               //Read-only variable, type inferred\n    val bb:Int = 2          //Read-only variable, type explicit\n\n    const val c = 3         //compile-time constant, type inferred\n    const val cc:Int = 3    //compile-time constant, type explicit\n\n    var str:String?= null    //nullable variable\n\n    lateinit var d:String    //initialized later\n</code></pre> Dart<pre><code>    var a = 1;              //variable, type inferred\n    int aa = 1;             //variable, type explicit\n\n    final b = 2;            //Read-only variable, type inferred\n    final int bb = 2;       //Read-only variable, type explicit\n\n    const c = 3;            //compile-time constant, type inferred\n    const int cc = 3;       //compile-time constant, type explicit\n\n    String? str;            //nullable variable, by default initialized to null\n\n    late String d;          //initialized later\n</code></pre></p>  <code>final</code> instead of <code>val</code> <p>Dart uses the <code>final</code> keyword for identifying readonly variables. Kotlin uses the <code>val</code> keyword</p>   <code>const</code> instead of <code>const val</code> <p>Dart uses the <code>const</code> keyword for identifying compile-time constants. Kotlin uses the combination of keywords <code>const val</code></p>   <code>const</code> is a more extended concept <p>see const variables and const constructors in Dart documentation.</p>   nullable variable are by default initialized to null <p>Dart automatically initializes to null nullable variables    </p>   <code>late</code> instead of <code>lateinit</code> <p>Kotlin <code>lateinit</code> variables are called <code>late</code> variables in Dart</p>"},{"location":"s02_built_in_types/","title":"Built-in types","text":""},{"location":"s02_built_in_types/#supertypes-for-all-types","title":"supertypes for all types","text":"<code>Object</code> instead of <code>Any</code> <p>in Dart the supertype of all  types is <code>Object</code>. In Kotlin it is <code>Any</code>. For nullable types it is <code>Object?</code> and <code>Any?</code> respectively</p>   <code>Enum</code> is the supertype of all Enums <p>in Dart there is also a special supertype for all enums</p>   <code>num</code> is the supertype of all numerical types <p>in Dart <code>int</code> and <code>double</code> has <code>num</code> as supertype </p>"},{"location":"s02_built_in_types/#numbers","title":"Numbers","text":"<code>int</code> (64 bit integer) instead of <code>Int</code> and <code>Long</code> <p>in Dart there is no 32bit integer type. Also on the web platform <code>int</code> is mapped to Javascript number  (64-bit floating-point values with no fractional part) and can be from -2^53 to 2^53 - 1.</p>   <code>double</code> (64 bit floating point) instead of <code>Float</code> and <code>Double</code> <p>in Dart there is no 32bit floating point type</p>"},{"location":"s02_built_in_types/#strings","title":"Strings","text":"<p>Kotlin<pre><code>var s = \"a string\"\nvar sraw =\n\"\"\"\na raw\nstring\n\"\"\"\n</code></pre> Dart<pre><code>var s1 = `a string`;\nvar s2= \"another string\";\nvar smulti1 = '''\nYou can create\nmulti-line strings like this one.\n''';\nvar smulti2 = \"\"\"This is also a\nmulti-line string.\"\"\";\nvar sraw = r'In a raw string, not even \\n gets special treatment.';\n</code></pre></p>  single quotes for strings <p>Dart allows both single and double quotes for defining string literals. In Kotlin double quotes are required while single quotes define character literals</p>   <code>String</code> is the same <p>in Dart <code>String</code> is a sequence of UTF-16 code units. in Kotlin <code>String</code> is also internally encoded in utf-16</p>   string interpolation works the same way <p>Dart see docs. Kotlin see docs</p>"},{"location":"s02_built_in_types/#booleans","title":"Booleans","text":"<code>bool</code> instead of  <code>Boolean</code> <p>see  Dart bool documentation. see Kotlin Boolean documentation</p>"},{"location":"s02_built_in_types/#lists","title":"Lists","text":"Kotlin<pre><code>var a_mutable_list = mutableListOf(1,2,3)\na_mutable_list.add(4)\nval a_final_list = listOf(1,2,3)\n\n//the proper type annotation for list type\nvar another_list:List&lt;Int&gt; = listOf(4,5,6)\n\n// kotlin does not have the list spread operator\nvar joined_list = a_final_list + another_list\nprintln(joined_list); //print [1,2,3,4,5,6]\n\n\n// kotlin does not have the collection_if syntax\nvar promoActive= true;\nvar nav = listOfNotNull(\"Home\", \"Furniture\", \"Plants\",\n                        if(promoActive) \"Outlet\" else null)\nprintln(nav); //print [Home, Furniture, Plants, Outlet] \n</code></pre> Dart<pre><code>var a_mutable_list= [1,2,3];\na_mutable_list.add(4);\n//cannot add elements to this list and it is a compile time constant\nvar const_list= const [1,2,3];\n\n//the same as writing const [1,2,3]: cannot add elements\n// to this list and it is also a compile time constant\nconst const_list2= [1,2,3];\n\n//the proper type annotation for list type\nList&lt;int&gt; another_list=[4,5,6];\n\n//usage of the spread operator   \nvar joined_list = [0, ...const_list, ...another_list];\nprint(joined_list); //print [0,1,2,3,4,5,6]\n\n//a null list: in Dart null variables are automatically initialized to null\nList&lt;int&gt;? null_list;\n\n//usage of the null-aware spread operator\nvar joined_list2 = [...const_list, ...?null_list];\nprint(joined_list2); //print [1,2,3]\n\n//collection_if operator\nvar promoActive= true;\nvar nav = ['Home', 'Furniture', 'Plants', if (promoActive) 'Outlet'];\nprint(nav); //print [Home, Furniture, Plants, Outlet]\n\n//collection_for operator\nvar listOfInts = [1, 2, 3];\nvar listOfStrings = ['#0', for (var i in listOfInts) '#$i'];  \nprint(listOfStrings); //print [#0, #1, #2, #3]\n</code></pre>  supported <code>List</code> operations are similar (but more limited) to <code>Collection</code> operations in Kotlin  <p>see  Dart List documentation. see Kotlin Collections operations</p>   lists has the collection spread operator <code>...</code>, and the null-aware collection spread operator <code>...?</code>  <p>see  Dart List documentation. see also the spread operator proposal.  Kotlin does not have the collection spread operator.</p>   lists has the <code>collection_if</code> construct <p>see  Dart List documentation. see also the control flow collections proposal.  Kotlin does not have the collection if syntax.</p>   lists has the <code>collection_for</code> construct <p>see  Dart List documentation. see also the control flow collections proposal.  Kotlin does not have the collection_for syntax.</p>"},{"location":"s02_built_in_types/#sets","title":"Sets","text":"Kotlin<pre><code>// a set\nvar halogens = \n    mutableSetOf(\"fluorine\", \"chlorine\", \"bromine\", \"iodine\", \"astatine\")\n\n// a set with the proper type annotation\nvar letters:MutableSet&lt;String&gt; = mutableSetOf(\"a\",\"b\",\"c\")\n\n// an empty set\nvar emptySet= mutableSetOf&lt;String&gt;()\n\n// an immutable set\nval constSet = setOf(\"a\",\"b\",\"c\")\n//the following line will cause a compilation error\n//constSet.add('d');\n</code></pre> Dart<pre><code>// a set\nvar halogens = {'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine'};\n\n // a set with the proper type annotation\nSet&lt;String&gt; letters = {'a','b','c'};\n\n// an empty set\nvar emptySet= &lt;String&gt;{};\n\n//this create a map not a set!\nvar emptyMap = {};\n\n// a constant set\nconst constSet = {'a','b','c'};\n//the following operation will throw an exception  \n//constSet.add('d');\n</code></pre>  see the supported <code>Set</code> operations <p>see also the Kotlin supported <code>Set</code> operations</p>   sets has the collection spread operator <code>...</code>, and the null-aware collection spread operator <code>...?</code>  <p>see  Dart spread operator documentation. see also the spread operator proposal.  Kotlin does not have the collection spread operator.</p>   sets has the <code>collection_if</code> construct <p>see  Dart collection_if documentation. see also the control flow collections proposal.</p> <p>Kotlin does not have the collection if syntax.</p>   sets has the <code>collection_for</code> construct <p>see  Dart collection_for documentation. see also the control flow collections proposal.  Kotlin does not have the collection_for syntax.</p>"},{"location":"s02_built_in_types/#maps","title":"Maps","text":"Kotlin<pre><code>//a Map&lt;Int,String&gt; object  \nvar nobleGases = mutableMapOf(\n  2 to \"helium\",\n  10 to \"neon\",\n  18 to \"argon\",\n)\n\n//a map with explicit type annotation\nvar nobleGases2:MutableMap&lt;Int, String&gt; = mutableMapOf()\n\n//an immutable map\nval constantMap = mapOf(\n  2 to \"helium\",\n  10 to \"neon\",\n  18 to \"argon\",\n)\n\n//constantMap[2] = 'Helium'; // This line will not compile\n</code></pre> Dart<pre><code>//a Map&lt;Int,String&gt; object  \nvar nobleGases = {\n  2: 'helium',\n  10: 'neon',\n  18: 'argon',\n};\n\n//a map with explicit type annotation\nMap&lt;int, String&gt; nobleGases2 = {};\n\n//a constant map\nfinal constantMap = const {\n  2: 'helium',\n  10: 'neon',\n  18: 'argon',\n};\n\n constantMap[2] = 'Helium'; // This line will throw an exception.  \n</code></pre>  see the supported <code>Map</code> operations <p>see also the Kotlin supported <code>Map</code> operations</p>   maps has the collection spread operator <code>...</code>, and the null-aware collection spread operator <code>...?</code>  <p>see  Dart spread operator proposal.  Kotlin does not have the collection spread operator.</p>   sets has the <code>collection_if</code> construct <p>see  Dart control flow collections proposal.  Kotlin does not have the collection if syntax.</p>   sets has the <code>collection_for</code> construct <p>see  Dart control flow collections proposal.  Kotlin does not have the collection_for syntax.</p>"},{"location":"s03_functions/","title":"Functions","text":""},{"location":"s03_functions/#simple-functions","title":"Simple functions","text":"Kotlin<pre><code>//standard syntax for function definition\nfun addTwo(cur:Int):Int {\n  return cur+2\n}\n\nprintln(addTwo(0)) //2\n\n//omitting function return type is not allowed unless it is Unit\nfun addArgs(arg1:Int,arg2:Int):Int {\n  return arg1+arg2 //return Int\n}\n\nprintln(addArgs(1,2))  // 3\n\n//if a function don't return a value, the type of the return value is Unit\nfun returnUnit() {\n\n}\n\nprintln(returnUnit()) //Unit\n\n//syntax for function that contains just an expression (no need to return type)\nfun isEvent(number:Int) = number%2==0\n\nprintln(isEvent(2)) //true\n</code></pre> Dart<pre><code>//standard syntax for function definition\nint addTwo(int cur) {\n  return cur+2;\n}\n\nprint(addTwo(0)); //2\n\n\n//omitting function return type and/or argument types is allowed\n// although not recommended for public APIs\n// if types are not specified they are consider of type \"dynamic\"\naddArgs(arg1,arg2) {\n  return arg1+arg2;\n}\n\nprint(addArgs(\"1\",\"2\")); //\"12\"\nprint(addArgs(1,2));  // 3\n\n\n\n//All functions return a value. If no return value is specified\n// the statement return null; is implicitly appended to the function body.\nint? returnNull() {\n\n}\n\nprint(returnNull()); //null\n\n\n//syntax for function that contains just an expression\nbool isEvent(int number) =&gt; number%2==0;\n\nprint(isEvent(2)); //true\n</code></pre>  function default return value is null <p>in Dart default return value is <code>null</code> . In Kotlin default return value is <code>Unit</code></p>   it is possible to omit parameters types and/or return value <p>in Dart function parameters with no specified type are considered <code>dynamic</code>, and return type if not specified is considered <code>dynamic</code>. In Kotlin parameter types must be specified, and also return value unless using the <code>fun function(&lt;params&gt;) = &lt;calculation&gt;</code> syntax</p>"},{"location":"s03_functions/#lambda-functions","title":"Lambda functions","text":"Kotlin<pre><code>//lambda functions and functions as objects\nval loudify = {msg:String -&gt; \"!!! ${msg.uppercase()} !!!\"}\n\nprintln(loudify(\"hello\")) // \"!!! HELLO !!!\"\n\n\n\n// lambda functions and functions as objects (with explicit return statement)\n// remember that if types of arguments are not specified, they are considered\n// of type \"dynamic\"\nval joinArgs = { a:String,b:String,c:String -&gt; a+b+c }\n\nprintln(joinArgs(\"a\",\"b\",\"c\")) //abc\n\n\n/// Lexical closures:\n/// Returns a function that adds [addBy] to the\n/// function's argument.\nfun makeAdder(addBy:Int):(Int)-&gt;Int {\n  return {i:Int -&gt; addBy + i}\n}\n\nvar adder=makeAdder(2)\nprintln(adder(2)) //4\n</code></pre> Dart<pre><code>//lambda functions and functions as objects\nfinal loudify = (String msg) =&gt; '!!! ${msg.toUpperCase()} !!!';\n\nprint(loudify(\"hello\")); // \"!!! HELLO !!!\"\n\n\n\n// lambda functions and functions as objects (with explicit return statement)\n// remember that if types of arguments are not specified, they are considered\n// of type \"dynamic\"\nfinal joinArgs = (a,b,c) { return a+b+c; };\n\nprint(joinArgs(\"a\",\"b\",\"c\")); //abc\n\n\n/// Lexical closures:\n/// Returns a function that adds [addBy] to the\n/// function's argument.\nFunction makeAdder(int addBy) {\n  return (int i) =&gt; addBy + i;\n}\n\nvar adder=makeAdder(2);\nprint(adder(2)); //4\n</code></pre>"},{"location":"s03_functions/#named-arguments-optional-positional-parameters","title":"Named Arguments, Optional Positional Parameters","text":"Dart<pre><code>// - A function can have any number of REQUIRED POSITIONAL parameters.\n//   These can be followed either by NAMED parameters or by OPTIONAL \n//   POSITIONAL parameters (but not both).\n// - Wrapping parameters in [] marks them as OPTIONAL POSITIONAL.\n// - Wrapping parameters in {} marks them as (optional) NAMED parameters:\n// - NAMED parameters annotated with \"required\" become mandatory parameters.\n// - If a parameter is optional but can\u2019t be null, provide a default value.\n//   use the syntax: &lt;Param&gt; = &lt;Value&gt; to define default values. \n//   Default values must be compile-time constants.\n//   If no default value is provided, the default value is null\nint addWithNamedParameters(int a, {required int b, int c=0}) {\n    var res=a+b+c;\n      return res;\n}\n\nint addWithOptionalPositionalParameters(int a, [int b=0, int c=0]) {\n    var res=a+b+c;\n      return res;\n}\n\nprint(addWithNamedParameters(1,b:2,c:3)); //6\nprint(addWithOptionalPositionalParameters(1)); //1\n</code></pre> Kotlin<pre><code>//actually in Kotlin any parameter can be a named parameter\nfun addWithNamedParameters(a:Int, b:Int, c:Int=0):Int {\n    var res=a+b+c\n    return res\n}\n\nfun addWithOptionalPositionalParameters(a:Int, b:Int=0, c:Int=0):Int {\n    var res=a+b+c\n    return res\n}\n\nprintln(addWithNamedParameters(1,b=2,c=3)) //6\nprintln(addWithOptionalPositionalParameters(1)) //1\n</code></pre>"},{"location":"s04_operators/","title":"Operators","text":""},{"location":"s04_operators/#arithmetic-operators","title":"Arithmetic Operators","text":"<p>They are the same (<code>+ - * / %</code> ) except for the divide and return integer operator <code>~/</code> Kotlin<pre><code>//Divide two operands and give integer output\nprintln((10.1).toInt() / 3); //3\n</code></pre> Dart<pre><code>//Divide two operands and give integer output\nprint(10.1~/3); //3\n</code></pre></p>"},{"location":"s04_operators/#equality-and-relational-operators","title":"Equality and Relational Operators","text":"<p>They are the same (<code>== != &lt; &lt;= &gt; &gt;=</code>) </p>"},{"location":"s04_operators/#reference-equality","title":"Reference equality","text":"<p>In Dart in order to check if two variables refers to the same class instance use <code>identical</code>. </p> <p>In Kotlin use <code>===</code>. Kotlin<pre><code>  var a = Point(1,1)\n  var b = a\n  assert(a===b)\n</code></pre> Dart<pre><code>  var a = Point(1,1);\n  var b = a;\n  assert(identical(a,b));\n</code></pre></p>"},{"location":"s04_operators/#type-test-and-type-cast-operators","title":"Type Test and Type Cast Operators","text":"<p>The are the same except for  <code>is!</code> in Dart that is <code>!is</code> in Kotlin. Kotlin has also the safe cast operator <code>as?</code> Kotlin<pre><code>//type cast\nval pp:Any = 1\nprintln(pp as Int + 2) //3\n\n//type check\nprintln(pp is Int) //true\nprintln(pp !is Int) //false\n</code></pre> Dart<pre><code>//type cast\nObject pp = 1;\nprint((pp as int) + 2); //3\n\n//type check\nprint(pp is int); //true\nprint(pp is! int); //false\n</code></pre></p>  <code>is!</code> instead of <code>!is</code> <p>in Dart <code>is!</code> is the operator for testing if an object is NOT of a type. In Kotlin  it is <code>!is</code> which is actually the <code>is</code> operator, prefixed by the logical not <code>!</code> operator</p>"},{"location":"s04_operators/#assignment-operators","title":"Assignment Operators","text":"<p>They are the same except for assigment operator based on Dart bitwise operators <code>&lt;&lt; &gt;&gt; &gt;&gt;&gt; ~ &amp; |</code>  and the divide and return integer operator <code>~/</code> which are not supported in Kotlin Kotlin<pre><code>var a = 1\na+=1\nprintln(a) //2\na-=1\nprintln(a) //1\n</code></pre> Dart<pre><code>var a = 1;\na+=1;\nprint(a); //2\na-=1;\nprint(a); //1\n</code></pre></p>"},{"location":"s04_operators/#logical-operator","title":"Logical Operator","text":"<p>They are the same (<code>&amp;&amp; || !</code> )</p>"},{"location":"s04_operators/#bitwise-and-shift-operators","title":"Bitwise and shift operators","text":"<p>Kotlin is known to use non-standard notations for bitwise and shift operators. So they are all different from Dart Kotlin<pre><code>fun toHex(num:Int) = num.toString(16)\n\n//bitwise AND\nprintln(toHex(0xffff and 0xff)) //ff\n\n//bitwise OR\nprintln(toHex(0xfff0 or 0x0fff)) //ffff\n\n//bitwise XOR\nprintln(toHex(0xfff0 xor 0x0fff)) //f00f\n\n//bitwise signed shift left\nprintln(1 shl 2) //4      \n\n//bitwise signed shift right\nprintln(4 shr 2) //1      \n\n//bitwise unsigned shift right\nprintln(4 ushr 2) //1\n\n//bitwise not\nprintln(toHex(0xff00ff00.toInt().inv()) ) //ff00ff\n</code></pre> Dart<pre><code>String toHex(int number) =&gt; number.toRadixString(16);\n\n//bitwise AND\nprint(toHex(0xffff &amp; 0xff)); //ff\n\n//bitwise OR\nprint(toHex(0xfff0 | 0x0fff)); //ffff\n\n//bitwise XOR\nprint(toHex(0xfff0 ^ 0x0fff)); //f00f\n\n//bitwise signed shift left\nprint(1 &lt;&lt; 2); //4      \n\n//bitwise signed shift right\nprint(4 &gt;&gt; 1); //1      \n//bitwise unsigned shift right\nprint(4 &gt;&gt;&gt; 1); //1      \n\n//bitwise not\nprint(toHex(~0xff00ff00) ); //ff00ff\n</code></pre></p>"},{"location":"s04_operators/#conditional-expressions","title":"Conditional expressions","text":"<p>Dart has the conditional operator Kotlin  has instead if-else expression Kotlin<pre><code>//conditional (ternary) operator\nvar smaller_than_ten=5\nvar bigger_than_ten=11\nprintln (if(smaller_than_ten&lt;10)  \"smaller\" else \"bigger\") //\"smaller\"\nprintln (if(bigger_than_ten&lt;10)  \"smaller\" else \"bigger\") //\"bigger\"\n</code></pre> Dart<pre><code>//conditional (ternary) operator\nvar smaller_than_ten=5;\nvar bigger_than_ten=11;\nprint (smaller_than_ten&lt;10 ? \"smaller\": \"bigger\"); //\"smaller\"\nprint (bigger_than_ten&lt;10 ? \"smaller\": \"bigger\"); //\"bigger\"\n</code></pre></p>"},{"location":"s04_operators/#null-coalescing-operator-elvis-operator","title":"Null coalescing operator (elvis operator)","text":"<p>Dart uses the <code>??</code> syntax Kotlin uses the <code>?:</code> syntax. Kotlin<pre><code>var a:String?=null\nvar b=\"b\"\nprintln(a?:b); //\"b\"\na=\"a\"\nprintln(a?:b); //\"a\"\n</code></pre> Dart<pre><code>var a=null;\nvar b='b';\nprint(a??b); //'b'\na='a';\nprint(a??b); //'a'\n</code></pre></p>"},{"location":"s04_operators/#member-access-operators","title":"Member Access Operators","text":"<p>They are the same (<code>. ?.</code>)</p>"},{"location":"s04_operators/#cascade-notation","title":"Cascade notation","text":"<p>In Dart Cascades (.., ?..) allow you to make a sequence of operations on the same object.</p> <p>in Kotlin there are instead the <code>with</code> and <code>apply</code> idioms. Kotlin<pre><code>var paint = Paint().apply {\n  color = Colors.black\n  strokeCap = StrokeCap.round\n  strokeWidth = 5.0\n}\n</code></pre> Dart<pre><code>var paint = Paint()\n  ..color = Colors.black //no semicolon here!!\n  ..strokeCap = StrokeCap.round //no semicolon here!!\n  ..strokeWidth = 5.0;\n</code></pre></p>"},{"location":"s04_operators/#not-null-assertion-operator","title":"Not Null assertion operator","text":"<p>In Dart the not null assertion operator is <code>!</code>. In Kotlin it is <code>!!</code></p>"},{"location":"s04_operators/#indexed-access-operator","title":"Indexed access operator","text":"<p>It is the same (<code>[]</code>)</p> <p>In Dart there is also the conditional indexed access operator <code>?[]</code>. In Kotlin <code>?[]</code> is not supported, but the indexed operator can specify more than one index.</p>"},{"location":"s04_operators/#invoke-function-call-operator","title":"Invoke (function call) operator","text":"<p>It is the same <code>()</code>.</p> <p>In Kotlin when overridden is <code>invoke</code> while in Dart is <code>call</code></p>"},{"location":"s05_control_flow/","title":"Control Flow","text":""},{"location":"s05_control_flow/#if-and-else","title":"<code>if</code> and <code>else</code>","text":"<p>They are the same. But Kotlin support also if-else expression</p>"},{"location":"s05_control_flow/#while-and-do-while-break-and-continue","title":"<code>while</code> and <code>do-while</code>, <code>break</code> and <code>continue</code>","text":"<p>They are the same: for Dart see here. For Kotlin see here</p>"},{"location":"s05_control_flow/#for-loops","title":"<code>for</code> loops","text":""},{"location":"s05_control_flow/#standard-loop","title":"standard loop","text":"<p>Kotlin<pre><code>//standard for loop    \nfor (i in 1..3 step 1) {\n    println(i) //1 2 3\n}\n\n//standard for loop: step 1 can be omitted\nfor (i in 1..3) {\n    println(i) //1 2 3\n}\n\n//standard reversed loop (note that the step is POSITIVE!)\nfor (i in 6 downTo 0 step 2) {\n    println(i) //6 4 2 0\n}\n\n//standard reversed loop: step 1 can be omitted\nfor (i in 6 downTo 0) {\n    println(i) //6 5 4 3 2 1 0\n}\n</code></pre> Dart<pre><code>//standard for loop    \nfor (var i=1; i&lt;=3; ++i) {\n    print(i); //1 2 3\n}\n\n//standard reversed loop\nfor (var i=6; i&gt;=0; i-=2) {\n    print(i); //6 4 2 0\n}\n</code></pre></p>"},{"location":"s05_control_flow/#loop-variable-captured-in-closure","title":"loop variable captured in closure","text":"<p>Kotlin<pre><code>//Closures inside of Kotlins\u2019s for loops capture the value of the index\nvar callbacks = mutableListOf&lt;()-&gt;Unit&gt;()\nfor (i in 0..2) {\n  callbacks.add({ println(i)})\n}\n// print 0 and then 1\ncallbacks.forEach{ c-&gt; c() }\n</code></pre> Dart<pre><code>//Closures inside of Dart\u2019s for loops capture the value of the index\nvar callbacks = [];\nfor (var i = 0; i &lt; 2; i++) {\n  callbacks.add(() =&gt; print(i));\n}\n// print 0 and then 1\ncallbacks.forEach((c) =&gt; c()); \n</code></pre></p>"},{"location":"s05_control_flow/#loop-over-iterable","title":"loop over iterable","text":"<p>For Dart see iteration in library-tour. For Kotlin see for loops and iterable in stdlib</p> <p>Kotlin<pre><code>var cities = listOf(\"Rome\",\"Paris\",\"London\")\n//iterate over elements of iterable\n// the same as in Dart see \n// see also \nfor(city:String in cities) //the String type annotation can be omitted\n{\n    println(city)    \n}\n</code></pre> Dart<pre><code>  //iterate over elements of iterable\n//see \nvar cities=[\"Rome\",\"Paris\",\"London\"];\nfor(final city in cities) //instead \"final\" we can specify \"var\" or the explicit type (String)\n{\n    print(city);    \n}\n</code></pre></p>"},{"location":"s05_control_flow/#iterableforeach","title":"iterable.forEach()","text":"<p>For Dart see forEach. For Kotlin see forEach in stdlib Kotlin<pre><code>//iterable has also a forEach method for iterating over the elements\ncities.forEach { city-&gt; println(city) }\n\n//or more simply\ncities.forEach{ println(it) }\n</code></pre> Dart<pre><code>//Iterable classes also have a forEach() method as another option:\n\ncities.forEach((city) {print(city);});\n\n//or more simply\ncities.forEach(print);\n</code></pre></p>"},{"location":"s05_control_flow/#switch-and-case","title":"<code>switch</code> and <code>case</code>","text":"<p>For Dart see switch and case. For Kotlin see when expression. Kotlin<pre><code>var job = \"nodejs dev\";\nval onJavascriptDev = { println(\"a Javascript dev\") }\nwhen (job) {\n    \"nodejs dev\" -&gt; {\n        println(\"a  nodejs dev\")\n        onJavascriptDev(); //no support to jump to another label like in Dart\n    }\n    \"frontend dev\" -&gt; {\n        println(\"a frontend deb\");\n        onJavascriptDev() //no support to jump to another label like in Dart\n    }\n    \"android dev\", \"iOS dev\" -&gt; println(\"A mobile dev\")\n    \"javascript dev\" -&gt; onJavascriptDev()\n    else -&gt; println(\"Unknown job\")\n}\n</code></pre> Dart<pre><code>var job='nodejs dev';\nswitch (job) {\n  case 'nodejs dev':\n    print(\"a  nodejs dev\");\n    continue javascript_dev;\n  case 'frontend dev':\n    print(\"a frontend deb\");\n    continue javascript_dev;\n  case 'android dev':\n  case 'iOS dev':\n    print(\"A mobile dev\");\n    break;\n  javascript_dev:    \n  case 'javascript dev':\n    print(\"a Javascript dev\");\n    break;\n  default:\n    print(\"Unknown job\");\n}\n</code></pre></p>   <code>case</code> fall-through is prohibited <p>Only empty  <code>case</code> fall-through is allowed.  Dart requires <code>break</code> at the end of each <code>case</code> . Other valid ways to end a non-empty case clause are a <code>continue</code> (continue execution to another clause), <code>throw</code>, or <code>return</code> statement.</p>   overriding == for compared object is prohibited <p>Dart does not allow classes for objects that are compared in a <code>switch</code> statement to override <code>operator==</code></p>"},{"location":"s05_control_flow/#assert","title":"<code>assert</code>","text":"<p>in Dart Debug mode use <code>assert(condition, optionalMessage)</code> to disrupt normal execution if a boolean condition is false.</p> <p>In Kotlin assert is supported for JVM and Native platforms; Kotlin<pre><code>// Make sure the variable has a non-null value.\nassert(text != null)\n\n// Make sure the value is less than 100.\nassert(number &lt; 100)\n\n// Make sure this is an https URL.\n//To attach a message to an assertion, add a string as the second argument to assert\nassert(urlString.startsWith(\"https\")){\"URL ($urlString) should start with \\\"https\\\".\"}\n</code></pre> Dart<pre><code>// Make sure the variable has a non-null value.\nassert(text != null);\n\n// Make sure the value is less than 100.\nassert(number &lt; 100);\n\n// Make sure this is an https URL.\n//To attach a message to an assertion, add a string as the second argument to assert\nassert(urlString.startsWith('https'),'URL ($urlString) should start with \"https\".');\n</code></pre></p>"},{"location":"s06_exceptions/","title":"Exceptions","text":"<p>Dart like Kotlin does not have checked Exception.</p> <p>In Kotlin only objects derived from Throwable can be throwed.  Dart can throw any object, but it is recommended to always use <code>Exception</code>, <code>Error</code> and their subclasses. </p> <p>Dart <code>Exception</code> class contains ony a message, while <code>Error</code> has a message and a stack trace. In Kotlin the base exception class <code>Throwable</code> has both a message and a stack trace.</p> <p>in Dart like in Kotlin  throwing and exception is an expression, and can be placed anywhere where an expression can be placed.</p> Kotlin<pre><code>class Exception1:Throwable()\nclass Exception2:Throwable()\nclass Exception3:Throwable()\n\n//when an exception occurs in a try-block, the exception type is checked\n//against each handler and the first one that matches is executed.\n//the finally block is executed always, both if an exception occurred or not.\n//There may be zero or more catch blocks, and the finally block may be omitted.\n// However, at least one catch or finally block is required.\ntry {\n    throw Exception3()\n} catch (e1:Exception1) { //handler for Exception1\n    println(\"Exception1 catched\")\n} catch (e2:Exception2) {  //handler for Exception2\n    println(\"Exception2 catched\")\n} catch (e2:Exception3) {  //handler for Exception3\n    println(\"Exception3 catched\")    \n} catch(e: Throwable) { //handler for all Throwable objects\n    println(\"${e::class} catched\")\n    throw e //propagate the exception further\n} finally {\n    println(\"in finally block\")\n}\n</code></pre> <p>Dart<pre><code>class Exception1 extends Error {}\nclass Exception2 extends Error {}\nclass Exception3 extends Error {}\n\ntry {\n    throw Exception3();\n} on Exception1 catch (e1,s1) { //handler for Exception1\n    //[catch (e1) can be omitted] s1 is the stack trace\n    print(\"Exception1 catched\");\n} on Exception2 catch (e2) {  //handler for Exception2\n    //[catch (e2) can be omitted]\n    print(\"Exception2 catched\");\n} on Exception3  {  //handler for Exception3\n    print(\"Exception3 catched\");\n} catch(e) { //handler for all Throwable objects\n    print(\"${e.runtimeType} catched\");\n    rethrow; //propagate the exception further\n} finally {\n    print(\"in finally block\");\n}\n</code></pre> for more information on Dart exception handling see library-tour</p>"},{"location":"s07_classes/","title":"Classes","text":"Use a dot <code>.</code> to refer to an instance variable or method. <p>This is the same in Dart and in Kotlin</p>    Use <code>?.</code> instead of <code>.</code> to avoid an exception when the leftmost operand is <code>null</code>. <p>This is the same in Dart and in Kotlin</p>"},{"location":"s07_classes/#methods-inherited-from-object","title":"methods inherited from <code>Object</code>","text":"<p>in Dart all types inherit from the supertype <code>Object</code> the methods <code>operator ==</code>,  <code>toString()</code> and the property <code>hashCode</code>. </p> <p>in Kotlin all types inherit from the supertype <code>Any</code> the methods <code>equals()</code>, <code>toString()</code> and <code>hashCode()</code>.</p>"},{"location":"s07_classes/#creating-a-class-instance","title":"Creating a  class instance","text":"<p>In Dart the <code>new</code> keyword before call to a class constructor is optional. In Kotlin the <code>new</code> keyword does not exist at all. Kotlin<pre><code>var p1 = Point(1,1)\nvar p2 = Point(2,2)\n</code></pre> Dart<pre><code>var p1 = Point(1,1);\nvar p2 = new Point(2,2);\n</code></pre></p>"},{"location":"s07_classes/#constant-constructors","title":"Constant Constructors","text":"<p>In Dart If your class produces objects that never change, you can make these objects compile-time constants. To do this, define a const constructor and make sure that all class fields are final. Constructing two identical const class instances results in a single, canonical instance:</p> <p>In Kotlin there is no such concept as const constructors.  Dart<pre><code>var a = const ImmutablePoint(1, 1);\nvar b = const ImmutablePoint(1, 1);\nassert(identical(a, b)); // They are the same instance!\n</code></pre> In Dart const constructors are \"activated\" by the <code>const</code> keyword before the call to the constructor. This define a const context: all const constructors used in the same line of code will be also activated, with no need to specifiy the <code>const</code> keyword before each of them.</p> <p>Dart<pre><code>// Lots of unneeded const keywords here.\nconst pointAndLine = const {\n  'point': const [const ImmutablePoint(0, 0)],\n  'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],\n};\n\n// the following line is equivalent to the previous one\n// and define the same const instance\nconst pointAndLine2 = const {\n  'point': [ ImmutablePoint(0, 0)],\n  'line': [ ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],\n};\nassert(identical(pointAndLine, pointAndLine2));\n</code></pre> Note that if the <code>const</code> keyword is not added before the call to a const constructor (or an outer constructor calling a nested constructor as explained above), the constructor will NOT create a compile-time constant:</p> Dart<pre><code>var a = const ImmutablePoint(1, 1); // Creates a constant\nvar b = ImmutablePoint(1, 1); // Does NOT create a constant\n\nassert(!identical(a, b)); // NOT the same instance!\n</code></pre>"},{"location":"s07_classes/#getting-an-objects-type","title":"Getting an object\u2019s type","text":"<p>In Dart to get an object\u2019s type at runtime, you can use the <code>Object</code> property <code>runtimeType</code>, which returns a <code>Type</code> object. In Kotlin instead you can use the syntax <code>::class</code></p> <p>Kotlin<pre><code>var a:Any=1\nprintln(a::class) // class kotlin.Int\n</code></pre> Dart<pre><code>Object a=1;\nprint(a.runtimeType); //int\n</code></pre></p>   Better use <code>is</code> than <code>runtimeType</code> to test an object\u2019s type. <p>In Dart, in production environments, using  <code>is</code> to test the object Type is more stable than using <code>object.runtimeType == Type</code>.</p>"},{"location":"s07_classes/#basic-class-declaration","title":"Basic Class declaration","text":"<p>Kotlin<pre><code>class Point {\n    var x:Double\n    var y:Double\n    constructor(x:Double,y:Double){\n        this.x = x\n        this.y = y\n    }\n}\n</code></pre> Dart<pre><code>class Point {\n  double x=0; //initialization required for avoiding compilation error unless field is nullable\n  double y=0; //initialization required for avoiding compilation error unless field is nullable\n\n  Point(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n</code></pre></p>"},{"location":"s07_classes/#constructors","title":"Constructors","text":""},{"location":"s07_classes/#initializing-formal-parameters","title":"Initializing formal parameters","text":"<p>Both in Dart and Kotlin there are better ways to write the code above. in  Kotlin there is the concept of primary constructor, in Dart there is the concept of initializing formal parameters that allow for a much more concise syntax: Kotlin<pre><code>class Point(var x:Double, var y:Double) //primary constructor\n\nclass PointXY(var x: Double, var y: Double) {\n    var z: Double\n    init { //init blocks are executed in the order they are found in the class definition\n        z = x * y\n    }\n}\n\n//or even better\nclass PointXY(var x: Double, var y: Double) {\n    var z: Double = x*y\n}\n</code></pre> Dart<pre><code>class Point {\n  double x,y;\n\n  // initializing formal parameters: \n  // use the first parameter provided to the constructor to initialize this.x\n  // use the second parameter provided to the constructor to initialize this.y\n  Point(this.x, this.y);\n}\n\nclass PointXY {\n  double x,y;\n\n  double xy=0; //initialization required for avoiding compilation error unless field is nullable\n\n  // NOTE: this.x and this.y are set  \n  // before the constructor body runs.\n  PointXY(this.x, this.y) {\n    xy=x*y;\n  }\n}\n</code></pre></p>"},{"location":"s07_classes/#default-constructors","title":"Default constructors","text":"<p>In Dart If you don\u2019t declare a constructor, a default constructor is provided for you. The default constructor has no arguments and invokes the no-argument constructor in the superclass. </p> <p>In Kotlin, for the JVM platform a parameterless constructor will be also generated if all the primary constructor parameters have default values. Kotlin<pre><code>class Point {\n    var x:Double=0.0\n    var y:Double=0.0\n}\nvar p = Point()\n</code></pre> Dart<pre><code>class Point {\n  double x=0;\n  double y=0;\n}\nvar p = Point();\n</code></pre></p>"},{"location":"s07_classes/#initializer-list","title":"Initializer list","text":"<p>In Dart if you want to initialize some fields in a constructor (with values not provided as parameters) there is a special syntax called <code>initializer list</code> This syntax is useful for example in named constructors.</p> <p>Dart<pre><code>class Point {\n  double x; //x not initialized here!\n  double y; //y not initialized here!\n\n  Point(): x=0, y=0; //initializer list\n}\n</code></pre> During development, you can validate inputs by using assert in the initializer list. Dart<pre><code>class Point {\n  double x; //x not initialized here!\n  double y; //y not initialized here!\n\n  //named constructor with parameter validation in initializer list\n  Point.withPositiveX(this.x,this.y): assert(x&gt;0); //initializer list\n}\n</code></pre> Initializer lists are handy when setting up final fields. The following example initializes three final fields in an initializer list Dart<pre><code>class Point {\n  final double x;\n  final double y;\n  final double distanceFromOrigin;\n\n  Point(double x, double y)\n      : x = x,\n        y = y,\n        distanceFromOrigin = sqrt(x * x + y * y);\n}\n</code></pre></p>"},{"location":"s07_classes/#named-constructors","title":"Named constructors","text":"<p>In Dart named constructor are constructors with a name appended (after a dot).</p> <p>In Kotlin an identical syntax at the constructor usage site, can be obtained with factory methods in the class companion object. Kotlin<pre><code>class Point(var x:Double,var y:Double) {\n    companion object {\n        fun origin() = Point(0.0,0.0)\n    }\n}\nvar p = Point.origin()\n</code></pre> Dart<pre><code>class Point {\n  final double x;\n  final double y;\n\n  Point(this.x, this.y);\n\n  // Named constructor\n  Point.origin()\n      : x = 0, y = 0; //this is called an initializer list\n}\n\nvar p = Point.origin(); \n</code></pre></p>"},{"location":"s07_classes/#redirecting-constructors","title":"Redirecting constructors","text":"<p>a constructor whose only purpose is to redirect to another constructor in the same class. Kotlin<pre><code>class Point(var x:Double,var y:Double) {\n    // Delegates to the main constructor.\n    constructor(x:Double): this(x,0.0)\n}\n</code></pre></p> Dart<pre><code>class Point {\n  double x, y;\n\n  // The main constructor for this class.\n  Point(this.x, this.y);\n\n  // Delegates to the main constructor.\n  Point.alongXAxis(double x) : this(x, 0);\n}\n</code></pre>"},{"location":"s07_classes/#constant-constructors_1","title":"Constant constructors","text":"<p>In Dart If your class produces objects that never change, you can make these objects compile-time constants. To do this, define a const constructor and make sure that all instance variables are final. Dart<pre><code>class ImmutablePoint {\n  //all fields are final: it is \n  //possible to have a constant constructor\n  final double x, y;\n  //contant constructor\n  const ImmutablePoint(this.x, this.y);\n}\n</code></pre></p>"},{"location":"s07_classes/#factory-constructors","title":"Factory constructors","text":"<p>In Dart  use the factory keyword when implementing a constructor that doesn\u2019t always create a new instance of its class. There are also other reasons to use a factory constructors. Factory constructors does not have access to <code>this</code>. In the following example, the Logger factory constructor returns objects from a cache, and the Logger.fromJson factory constructor initializes a final variable from a JSON object. Dart<pre><code>class Logger {\n  final String name;\n  bool mute = false;\n\n  // _cache is library-private, thanks to\n  // the _ in front of its name.\n  static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{};\n\n  //a factory constructor that create a new object only if not already present in _cache\n  factory Logger(String name) {\n    return _cache.putIfAbsent(name, () =&gt; Logger._internal(name));\n  }\n  //an internal named constructor\n  Logger._internal(this.name);\n\n  void log(String msg) {\n    if (!mute) print(msg);\n  }\n}\n</code></pre></p>"},{"location":"s07_classes/#operators","title":"Operators","text":"<p>For Dart see here,  for  Kotlin see here</p> Kotlin<pre><code>class Vector( var x:Double, var y:Double) {\n    operator fun plus(other:Vector):Vector {\n        return Vector(x+other.x,y+other.y)\n    }\n    override fun toString():String =\"x:$x, y:$y\"\n}\n\nvar a=Vector(2.0,0.0)\nvar b=Vector(0.0,3.0)\nvar c= a+b\nprintln(c) //x:2.0, y:3.0\n</code></pre> Dart<pre><code>class Vector {\n  final double x, y;\n  Vector(this.x, this.y);\n  Vector operator+(Vector other) {\n    return Vector(x+other.x,y+other.y);\n  }\n  @override\n  String toString() =&gt; \"x:$x, y:$y\";\n}\n\nvar a=Vector(2.0,0.0);\nvar b=Vector(0.0,3.0);\nvar c = a+b;\nprint(a+b); //x:2, y:3\n</code></pre>"},{"location":"s07_classes/#getters-and-setters","title":"Getters and Setters","text":"<p>For Dart see here for Kotlin see here</p> Kotlin<pre><code>class Square(var side:Double) {\n  var area:Double \n    get() = side*side\n    set(value) { side = Math.sqrt(value) }\n}\n\nvar sq=Square(10);\nprint(sq.area); //100 \nsq.area=81;\nprint(sq.side); //9\n</code></pre> Dart<pre><code>class Square {\n  double side;\n  Square(this.side);\n  double get area { return side*side; }\n  set area(double newArea) { side = sqrt(newArea); }\n}\n\nvar sq=Square(10);\nprint(sq.area); //100 \nsq.area=81;\nprint(sq.side); //9\n</code></pre>"},{"location":"s07_classes/#static-variables-and-methods","title":"Static Variables and Methods","text":"<p>For Dart see here. For Kotlin see here</p> Kotlin<pre><code>class Point(val x:Double, val y:Double) {\n    companion object {\n        val origin = Point(0.0,0.0)\n        fun distanceBetween(a:Point, b:Point):Double {\n            val dx = a.x - b.x\n            val dy = a.y - b.y\n            return sqrt(dx * dx + dy * dy)\n        }  \n    }\n}\nvar a = Point.origin\nvar b = Point(3.0, 4.0)\nvar distance = Point.distanceBetween(a, b)\nprintln(distance); //5\n</code></pre> Dart<pre><code>class Point {\n  final x, y;\n  Point(this.x, this.y);\n\n  static final Point origin = Point(0.0,0.0);\n  static double distanceBetween(Point a, Point b) {\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n  }\n}\nvar a = Point.origin;\nvar b = Point(3, 4);\nvar distance = Point.distanceBetween(a, b);\nprint(distance); //5\n</code></pre>"},{"location":"s07a_classes_hierarchies/","title":"Class Hierarchies","text":""},{"location":"s07a_classes_hierarchies/#interfaces","title":"Interfaces","text":"<p>Kotlin<pre><code>interface IShapeWithArea {\n  fun area():Double { return 0.0 } //default method implementation (optional)\n}\n\ninterface IShapeWithPerimeter {\n  fun perimeter():Double { return 0.0 }\n}\n\n//in Kotlin we must specify this interface explicitly\ninterface IRectangle {\n    var w:Double\n    var h:Double\n}\n\nclass Rectangle(override var w:Double,override var h:Double)\n : IShapeWithArea,IShapeWithPerimeter,IRectangle \n{\n  override fun area()= w*h\n  override fun perimeter()=2*w+2*h\n}\n\nclass Square(var side:Double) : IShapeWithArea,IShapeWithPerimeter,IRectangle\n{\n  //from IShapeWithArea\n  override fun area() = side*side\n  //from IShapeWithPerimeter\n  override fun perimeter() = 4*side\n  //from IRectangle\n  override var w:Double \n    get() =side \n    set(value) {side=value } \n  //from IRectangle\n  override var h:Double \n    get() =side \n    set(value) {side=value }     \n}\n</code></pre> Dart<pre><code>// Every class in Dart* implicitly defines an interface \n// containing all fields and methods\n// of the class and of any interfaces it implements.\nclass IShapeWithArea {\n  double area() { return 0; }\n}\n\nclass IShapeWithPerimeter {\n  double perimeter() { return 0; }\n}\n\n// when using the \"implements\" keyword, we specify that we want\n// to implement the implicit interface defined\n// by the classes IShapeWithArea,IShapeWithPerimeter\nclass Rectangle implements IShapeWithArea,IShapeWithPerimeter {\n  double w,h;\n  Rectangle(this.w,this.h);\n  @override\n  double area() =&gt; w*h;\n  @override\n  double perimeter() =&gt; 2*w+2*h;    \n}\n\nclass Square implements IShapeWithArea,IShapeWithPerimeter,Rectangle\n{\n  double side;\n  Square(this.side);\n  //from IShapeWithArea\n  @override\n  double area() =&gt; side*side; \n  //from IShapeWithPerimeter\n  @override\n  double perimeter() =&gt; 4*side; \n  //from Rectangle\n  @override\n  double get w =&gt; side;\n  @override\n  set w(double value) { side=value; }\n  @override\n  //from Rectangle\n  double get h =&gt; side;\n  @override\n  set h(double value) { side=value; }\n}\n</code></pre></p>   no <code>interface</code> keyword <p>In Dart every class implicitly defines an interface containing all fields and methods of the class and of any interfaces it implements. </p> <p>In Kotlin there are explicit interfaces.</p>"},{"location":"s07a_classes_hierarchies/#abstract-classes","title":"Abstract Classes","text":"<p>Kotlin<pre><code>class Color(val r:Int,val g:Int, val b:Int)\n\n//abstract classes can contains data fields (unlike interfaces)\nabstract class ColoredShape(var fillColor:Color,var borderColor:Color) {\n    abstract fun area():Double\n    abstract fun perimeter():Double\n    fun areaToPerimeterRation():Double = area()/perimeter()\n}\n\ninterface IRectangle {\n    var w:Double\n    var h:Double\n}\n\nclass Rectangle(\n    override var w:Double,override var h:Double,\n    fillColor:Color, borderColor:Color) \n: IRectangle,ColoredShape(fillColor,borderColor) {\n  override fun area()= w*h\n  override fun perimeter()=2*w+2*h\n}\n\nclass Square(var side:Double,\n            fillColor:Color, borderColor:Color) \n: IRectangle,ColoredShape(fillColor,borderColor)\n{\n  override fun area() = side*side\n  override fun perimeter() = 4*side\n  override var w:Double \n    get() =side \n    set(value) {side=value } \n  override var h:Double \n    get() =side \n    set(value) {side=value }     \n}\n</code></pre> Dart<pre><code>class Color\n{\n  int r,g,b;\n  Color(this.r,this.g,this.b);\n}\n\nabstract class ColoredShape \n{\n  Color fillColor,borderColor;\n  ColoredShape(this.fillColor,this.borderColor);\n  double area(); //method with no implementation: abstract\n  double perimeter(); //method with no implementation: abstract\n  double areaToPerimeterRation() =&gt; area()/perimeter();\n}\n\n// use the \"extends\" keyword to extend another class (abstract or not)\nclass Rectangle extends ColoredShape {\n  double w,h;\n  //define in constructor also fields of parent class ColoredShape constructor\n  Rectangle(this.w,this.h,super.fillColor,super.borderColor);\n  @override\n  double area() =&gt; w*h;\n  @override\n  double perimeter() =&gt; 2*w+2*h;    \n}\n\nclass Square  extends ColoredShape implements Rectangle\n{\n  double side;\n  //define in constructor also fields of parent class ColoredShape constructor\n  Square(this.side,super.fillColor,super.borderColor);\n  @override\n  double area() =&gt; side*side; \n  @override\n  double perimeter() =&gt; 4*side; \n  @override\n  double get w =&gt; side;\n  @override\n  set w(double value) { side=value; }\n  @override\n  double get h =&gt; side;\n  @override\n  set h(double value) { side=value; }\n}\n</code></pre></p>  all classes are open, all methods are open <p>In Dart all classes can be extended (inherited from) not only abstract classes. In Kotlin only open classes can be inherited from, and only open methods can be overridden.</p>"},{"location":"s07a_classes_hierarchies/#nosuchmethod","title":"NoSuchMethod()","text":"<p>for <code>dynamic</code> types, Dart support special handling of cases where a not existent method is invoked Dart<pre><code>class A {\n  // Unless you override noSuchMethod, using a\n  // non-existent member results in a NoSuchMethodError.\n  @override\n  void noSuchMethod(Invocation invocation) {\n    print('You tried to use a non-existent member: '\n        '${invocation.memberName}');\n  }\n}\n</code></pre></p>"},{"location":"s07b_classes_enums/","title":"Enums","text":"<p>For Dart see here. For Kotlin see here Kotlin<pre><code>//a simple enum\nenum class Color { red, green, blue }\n\n\n// an \"enhanced\" enum (an enum whose instances are more like classes)\n// note that a semicon is required at the end of the list of possible \n// enum values, before definitions of enum fields and methods. \nenum class Vehicle(\n    val tires:Int,\n    val passengers:Int,\n    val carbonPerKilometer:Int) : Comparable&lt;Vehicle&gt; {\n    car(tires= 4, passengers= 5, carbonPerKilometer= 400),\n    bus(tires= 6, passengers= 50, carbonPerKilometer= 800),\n    bicycle(tires= 2, passengers= 1, carbonPerKilometer= 0); //SEMICOLON HERE!\n\n    val carbonFootprint:Int get() =\n        Math.round(carbonPerKilometer.toDouble() / passengers).toInt()\n\n    //cannot override compareTo in enums in Kotlin(Java)\n    // so we define a custom method\n    fun compare(other:Vehicle):Int =\n        carbonFootprint - other.carbonFootprint\n}\n\n//enum index \n// (the index of the corresponding enum label in the enum definition)\n// This is also the index of the value in the \"values\" list.\n// prints  \"0,1,2\"\nprintln (\"${Color.red.ordinal}, ${Color.green.ordinal}, ${Color.blue.ordinal}\")\n\n//list of all enum labels (List&lt;Color)\n// values() returns an array \n// array does not have a proper toString() implementation, \n// so we convert it to list for printing it\nprintln(Color.values().toList()) //[red,green,blue]\n\n//the name for some enum label  \nprintln(Color.blue.name);  //blue\n</code></pre> Dart<pre><code>//a simple enum\nenum Color { red, green, blue }\n\n//an \"enhanced\" enum (enum that are more like classes)\nenum Vehicle implements Comparable&lt;Vehicle&gt; {\n  car(tires: 4, passengers: 5, carbonPerKilometer: 400),\n  bus(tires: 6, passengers: 50, carbonPerKilometer: 800),\n  bicycle(tires: 2, passengers: 1, carbonPerKilometer: 0);\n\n  const Vehicle({\n    required this.tires,\n    required this.passengers,\n    required this.carbonPerKilometer,\n  });\n\n  final int tires;\n  final int passengers;\n  final int carbonPerKilometer;\n\n  int get carbonFootprint =&gt; (carbonPerKilometer / passengers).round();\n\n  @override\n  int compareTo(Vehicle other) =&gt; carbonFootprint - other.carbonFootprint;\n}\n\n//enum index \n// (the index of the corresponding enum label in the enum definition)\n// This is also the index of the value in the \"values\" list.\nprint (\"${Color.red.index}, ${Color.green.index}, ${Color.blue.index}\"); //0,1,2\n\n// list of all enum labels (List&lt;Color&gt;)\nprint(Color.values); //[Color.red, Color.green, Color.blue]\n\n// the name for some enum label  \nprint(Color.blue.name);  //blue\n</code></pre></p>"},{"location":"s07c_classes_extensions_methods/","title":"Extension Methods","text":"<p>For Dart see here, for Kotlin see here</p> Kotlin<pre><code>fun String.parseInt():Int {\n    //kotlin already have a similar extension method: redirect to it\n    return this.toInt()\n}\nfun String.parseDouble():Double {\n    //kotlin already have a similar extension method: redirect to it\n    return this.toDouble()\n}\n\nfun &lt;T&gt; MutableList&lt;T&gt;.swap(index1: Int, index2: Int) {\n    val tmp = this[index1] // 'this' corresponds to the list\n    this[index1] = this[index2]\n    this[index2] = tmp\n}\n\nprintln(\"123\".parseInt()+1); //124\nprintln(\"123.0\".parseDouble()+0.5); //123.5\n\nvar list= mutableListOf(0,1,2,3)\nlist.swap(0,1);\nprintln(list); //1,0,2,3\n</code></pre> Dart<pre><code>// extension method are defined as part of a named extension block\n// it is used in Dart to help resolving conflicting extension method definitions\nextension NumberParsing on String {\n  int parseInt() {\n    return int.parse(this);\n  }\n  double parseDouble() {\n    return double.parse(this);\n  }\n  // \u00b7\u00b7\u00b7\n}\n\n// it is possible to define extension methods on a generic type. \n// This is the syntax\nextension ListSwap&lt;T&gt; on List&lt;T&gt; {\n  void swap(int index1, int index2) {\n    final tmp= this[index1];\n    this[index1]=this[index2];\n    this[index2]=tmp;\n  }\n}\n\n// To create a local extension that\u2019s visible only in the library \n// where it\u2019s declared, either omit the extension name\n// or give it a name that starts with an underscore (_)\nextension on String {\n  String wrappedWithA() {\n    return \"A${this}A\";\n  }\n}\n\nprint('123'.parseInt()+1); //124\nprint('123.0'.parseDouble()+0.5); //123.5\n\nvar list= [0,1,2,3];\nlist.swap(0,1);\nprint(list); //1,0,2,3\nprint ('BB'.wrappedWithA()); //ABBA\n</code></pre>   extensions are resolved statically <p>Both in Dart and in Kotlin extensions are resolved statically. In other words the dynamic type at runtime does not count. What counts is the resolved  static type at a compile time. </p>"},{"location":"s07c_classes_extensions_methods/#extension-methods-visibility","title":"Extension Methods Visibility","text":"<p>There are several important details about extension methods visibility and disambiguation. For Dart see here for Kotlin see here </p>"},{"location":"s07d_classes_mixins/","title":"Mixins","text":"<p>For Dart see here.  Mixins classes are not allowed to have a constructor.</p> <p>Kotlin does not have mixins, but it has instead something similar that is called delegation Also Kotlin interfaces with method implementations can be used, in some cases, instead of mixins.</p> Kotlin<pre><code>interface Person {\n    val name:String\n    val surname:String\n}\n\n// interface with method implentations and properties\n// (but no actual data)\ninterface Musical : Person{\n  var canPlayPiano:Boolean\n  var canCompose:Boolean\n  var canConduct:Boolean\n\n  fun entertainMe() {\n    println(\"${name} ${surname} is\")\n    if (canPlayPiano) {\n      println(\"Playing piano\")\n    }\n    if (canConduct) {\n      println(\"Waving hands\")\n    }\n    if (canCompose) {\n      println(\"Humming to self\")\n    }\n    println(\"\")\n  }\n}\n\n// MusicalImpl is the class  we will \"delegate to\" \n// for implementing the \"Musical\" interface.\n// it is equivalent to the \"Musical\" mixin in Dart code\nclass MusicalImpl(\n  override val name:String,override val surname:String):Musical {\n  override var canPlayPiano:Boolean=false\n  override var canCompose:Boolean=false\n  override var canConduct:Boolean=false\n}\n\n// a class that has \"Person\" as superclass and\n// delegate implementation of the \"Musical\" interface \n// to the MusicalImpl class\nclass Pianist(name:String, surname:String)\n : Musical by MusicalImpl(name,surname)\n{\n  init {\n      canPlayPiano=true //from  \"Musical\" \n    }\n}\n\n// a class that has \"Person\" as superclass and\n// delegate implementation of the \"Musical\" interface \n// to the MusicalImpl class\nclass Maestro(name:String, surname:String)\n : Musical by  MusicalImpl(name,surname)\n{\n  init {\n    canConduct=true //from  \"Musical\"\n  }\n}\n\n// a class that has \"Person\" as superclass and\n// delegate implementation of the \"Musical\" interface \n// to the MusicalImpl class\nclass Composer(name:String, surname:String)\n : Musical by  MusicalImpl(name,surname)\n{\n  init {\n    canCompose=true //from  \"Musical\" \n  }\n}\n\nvar p=Pianist(\"Glenn\",\"Gould\")\nvar m=Maestro(\"Zubin\",\"Mehta\")\nvar c=Composer(\"Fr\u00e9d\u00e9ric\",\"Chopin\")\nc.canPlayPiano=true //chopin was also a virtuoso Pianist\n\np.entertainMe() //Glenn Gould is Playing piano\nm.entertainMe() // Zubin Mehta is Waving hands\nc.entertainMe() //Fr\u00e9d\u00e9ric Chopin is Playing piano Humming to self\n</code></pre> Dart<pre><code>class Person {\n  final String name;\n  final String surname;\n  Person(this.name,this.surname);\n}\n\n// a mixin in Dart\n// defines a class that CANNOT BE instantiated, \n// but can be included in another class as a mixin\n// with the \"with\" keyword\n// the \"on &lt;class name&gt;\" class restricts the classes \n// that can use the mixin to only the classes that derives from\n// some specific superclass, in this case \"Person\" \n// because the mixin implementation depends on\n// the availability of fields and methods\n// from that superclass\n// All the mixin methods and fields will be available to the class that\n// include it with the \"with\" keyword\nmixin Musical on Person {\n  bool canPlayPiano = false;\n  bool canCompose = false;\n  bool canConduct = false;\n\n  void entertainMe() {\n    print(\"${name} ${surname} is\");\n    if (canPlayPiano) {\n      print('Playing piano');\n    }\n    if (canConduct) {\n      print('Waving hands');\n    }\n    if (canCompose) {\n      print('Humming to self');\n    }\n    print(\"\");\n  }\n}\n\n\n\n// a class that has \"Person\" as superclass and\n// use the \"Musical\" mixin\nclass Pianist extends Person with Musical {\n  Pianist(super.name,super.surname) {\n      canPlayPiano=true; //from the \"Musical\" mixin\n    }\n}\n\n// a class that has \"Person\" as superclass and\n// use the \"Musical\" mixin\nclass Maestro extends Person  with Musical {\n  Maestro(super.name,super.surname) {\n    canConduct=true; //from the \"Musical\" mixin\n  }\n}\n\n// a class that has \"Person\" as superclass and\n// use the \"Musical\" mixin\nclass Composer extends Person  with Musical {\n  Composer(super.name,super.surname) {\n    canCompose=true; //from the \"Musical\" mixin\n  }\n}\n\n\nvar p=Pianist(\"Glenn\",\"Gould\");\nvar m=Maestro(\"Zubin\",\"Mehta\");\nvar c=Composer(\"Fr\u00e9d\u00e9ric\",\"Chopin\");\nc.canPlayPiano=true; //chopin was also a virtuoso Pianist\n\np.entertainMe(); //Glenn Gould is Playing piano\nm.entertainMe(); // Zubin Mehta is Waving hands\nc.entertainMe(); //Fr\u00e9d\u00e9ric Chopin is Playing piano Humming to self\n</code></pre>"},{"location":"s08_generics/","title":"Generics","text":"<p>For Dart see here. For Kotlin see here</p>  The syntax for creating and using classes with type parameters is the same   Generics are reified <p>In Dart  generic types are reified, which means that they carry their type information around at runtime.</p> <p>In Kotlin, like in Java, generics use type erasure, which means that generic type parameters are removed at runtime: you can test whether an object is a <code>List</code>, but you can\u2019t test whether it\u2019s a <code>List&lt;String&gt;</code>. But there is a work-around, that is inline functions with reified type parameters </p>"},{"location":"s08_generics/#generic-types-in-collections","title":"Generic types In collections","text":"<p>Kotlin<pre><code>// note: the explicit type parameter here is actually redundant\nvar names = mutableListOf&lt;String&gt;(\"Seth\", \"Kathy\", \"Lars\")\n\n// note: the explicit type parameter here is actually redundant\nvar uniqueNames = mutableSetOf&lt;String&gt;(\"Seth\", \"Kathy\", \"Lars\")\n\n// note: the explicit type parameter here is actually redundant\nvar pages = mutableMapOf&lt;String, String&gt;(\n  \"index.html\" to \"Homepage\",\n  \"robots.txt\" to \"Hints for web robots\",\n  \"humans.txt\" to \"We are people, not machines\"\n  )\n</code></pre> Dart<pre><code>//define a List&lt;String&gt;\n// note: the explicit type parameter here is actually redundant\nvar names = &lt;String&gt;['Seth', 'Kathy', 'Lars'];\n\n//define a Set&lt;String&gt;\n// note: the explicit type parameter here is actually redundant\nvar uniqueNames = &lt;String&gt;{'Seth', 'Kathy', 'Lars'};\n\n//define a Map&lt;String,String&gt;\n// note: the explicit type parameter here is actually redundant\nvar pages = &lt;String, String&gt;{\n  'index.html': 'Homepage',\n  'robots.txt': 'Hints for web robots',\n  'humans.txt': 'We are people, not machines'\n  };\n}\n</code></pre></p>"},{"location":"s08_generics/#restricting-the-generic-type","title":"Restricting the generic type","text":"<p>Kotlin<pre><code>interface Animal \nclass Dog(var name:String):Animal\nclass Cat(var name:String):Animal\n\n//a pair of any objects that derive from the Animal base class\nclass PairOfAnimals&lt;A : Animal&gt;(var first:A, var second:A) \n\nvar p1 = PairOfAnimals(Dog(\"Pluto\"),Dog(\"Max\")) //ok\nvar p2 = PairOfAnimals(Dog(\"Pluto\"),Cat(\"Felix\")) //ok\nvar p3 = PairOfAnimals(Cat(\"Tom\"),Cat(\"Felix\")) //ok\n\n//compilation error! String is not an Animal\nvar p4 = PairOfAnimals(\"aa\",Cat(\"Felix\"))\n</code></pre> Dart<pre><code>class Animal {}\nclass Dog implements Animal {\n  String name;\n  Dog(this.name);\n}\nclass Cat implements Animal {\n  String name;\n  Cat(this.name);\n}\n\n//a pair of any objects that derive from the Animal base class\nclass PairOfAnimals&lt;A extends Animal&gt; {\n  A first,second;\n  PairOfAnimals(this.first,this.second);\n}\n\nvar p1 = PairOfAnimals(Dog(\"Pluto\"),Dog(\"Max\")); //ok\nvar p2 = PairOfAnimals(Dog(\"Pluto\"),Cat(\"Felix\")); //ok\nvar p3 = PairOfAnimals(Cat(\"Tom\"),Cat(\"Felix\")); //ok\n\n//compilation error! String is not an Animal\nvar p4 = PairOfAnimals(\"aa\",Cat(\"Felix\"));\n</code></pre></p>  Handling bounds on generic type can be much more complex in Kotlin <p>see Kotlin docs</p>"},{"location":"s08_generics/#restricting-to-non-nullable-type","title":"Restricting to non-nullable type","text":"<p>Kotlin<pre><code>// only non nullable type parameters allowed\n// (Any is base type of all non-nullable types)\nclass SomeClass&lt;T:Any&gt;\n</code></pre> Dart<pre><code>// only non-nullable type parameters allowed\n// (Object is base type of all non-nullable types)\nclass SomeClass&lt;T extends Object&gt;\n</code></pre></p>"},{"location":"s08_generics/#instantiating-generic-class-with-no-type-parameter","title":"Instantiating generic class with no type parameter","text":"<p>In Dart it is possible to instantiate a generic class without specifying the type parameter.  Dart<pre><code>class SomeBaseType {}\nclass SomeClass&lt;T extends SomeBaseType&gt; {}\nvar foo = SomeClass(); //instance of SomeClass&lt;SomeBaseType&gt;\n</code></pre></p>"},{"location":"s08_generics/#generic-methods","title":"Generic methods","text":"<p>Kotlin<pre><code>fun  &lt;T&gt; extractFirstElement(ts:List&lt;T&gt;):T {\n  // show that we can use the type parameter inside the function\n  var tmp:T = ts[0];\n  return tmp;\n}\nvar cities = listOf(\"Rome\",\"Paris\",\"New York\")\nvar first_city= extractFirstElement(cities)\nprint(first_city) //Rome\n</code></pre> Dart<pre><code>T extractFirstElement&lt;T&gt;(List&lt;T&gt; ts) {\n  // show that we can use the type parameter inside the function\n  T tmp = ts[0];\n  return tmp;\n}\n\nvar cities = ['Rome','Paris','New York'];\nvar first_city= extractFirstElement(cities);\nprint(first_city); //Rome\n</code></pre></p>"},{"location":"s09_visibility/","title":"Libraries and Visibility","text":"<p>DOCUMENTATION COMING SOON!</p>"},{"location":"s10_asynchrony/","title":"Asynchrony support","text":"<p>In Dart asynchrony support is very similar to javascript. It is based on  - async/await - futures - streams and async generators</p> <p>In Kotlin we have coroutines</p>"},{"location":"s14_typedefs/","title":"Typedefs","text":"<p>For Dart see here. For Kotlin see here</p> Kotlin<pre><code>typealias IntList = List&lt;Int&gt;\n\ntypealias ListMapper&lt;X&gt; = Map&lt;X, List&lt;X&gt;&gt;\n\ntypealias Compare&lt;T&gt; = (a:T,b:T) -&gt; Int\n\nvar il:IntList = listOf(1, 2, 3)\nvar m2:ListMapper&lt;String&gt;  = mapOf()\n\nval sort:Compare&lt;Int&gt; = { a,b -&gt; a-b }\n\n// in Kotlin I cannot check the following,\n// because kotlin generics has type erasure,\n// in other words we cannot check if \n// sort is Compare&lt;String&gt; or Compare&lt;Int&gt;\n// or any other type parameter  \n\n /* print(sort is Compare&lt;String&gt;); // false */\n\n print(sort is Compare&lt;Int&gt;) // true\n</code></pre> Dart<pre><code>typedef IntList = List&lt;int&gt;;\n\ntypedef ListMapper&lt;X&gt; = Map&lt;X, List&lt;X&gt;&gt;;\n\ntypedef Compare&lt;T&gt; = int Function(T a, T b);\n\nint sort(int a, int b) =&gt; a - b;\n\nIntList il = [1, 2, 3];\nListMapper&lt;String&gt; m2 = {};\nprint(sort is Compare&lt;String&gt;); // false\n\nprint(sort is Compare&lt;int&gt;); // true\n</code></pre>  Don't overuse <code>typedef</code> for function types <p>in Dart 1.0 if you wanted to use a function type for a field, variable, or generic type argument, you had to first define a typedef for it. From Dart 2.0 this is no more required</p>"},{"location":"s15_metadata/","title":"Metadata","text":"<p>DOCUMENTATION COMING SOON!</p>"},{"location":"s16_comments/","title":"Comments","text":""},{"location":"s16_comments/#single-line-comments","title":"Single-line Comments","text":"work the same way <p>Dart see docs. Kotlin see docs</p>"},{"location":"s16_comments/#multi-line-comments","title":"Multi-line Comments","text":"work the same way <p>Dart see docs. Kotlin see docs</p>"},{"location":"s16_comments/#documentation-comments","title":"Documentation Comments","text":"work in a similar way <p>Dart see docs. Kotlin see docs In Dart it is possible to define documentation comments with multiple single-line comments started with <code>///</code></p>"},{"location":"s17_idioms/","title":"Idioms","text":""},{"location":"s17_idioms/#copying-a-list-a-set-a-map","title":"Copying a <code>list</code>, a <code>set</code>, a <code>map</code>","text":"Kotlin<pre><code>var aList=listOf(1,2,3)\n//also toList() work, but then the copy is immutable\nvar listCopy = aList.toMutableList()\nlistCopy.add(4)\nprintln(aList) //1,2,3\nprintln(listCopy) //1,2,3,4\n\nvar aMap = mapOf(\"a\" to 1,\"b\" to 2,\"c\" to 3)\n// also .toMap() works, but then the copy is immutable\nvar mapCopy = aMap.toMutableMap()\n\nvar aSet = setOf(\"a\",\"b\",\"c\")\n// also .toSet() works, but then the copy is immutable\nval setCopy = aSet.toMutableSet() \n</code></pre> Dart<pre><code>var aList=[1,2,3];\nvar listCopy = [...aList];\nlistCopy.add(4);\nprint(aList); //1,2,3\nprint(listCopy); //1,2,3,4\n\nvar aMap = {\"a\":1,\"b\":2,\"c\":3};\nvar mapCopy = {...aMap};\n\nvar aSet = {\"a\",\"b\",\"c\"};\nvar setCopy = {...aSet};\n</code></pre>"},{"location":"s17_idioms/#checking-parameters-validity-and-assigning-fields-in-constructor","title":"checking parameters validity and assigning fields in constructor","text":"Dart<pre><code>class Rectangle {\n  final double width;\n  final double height;\n  final double area;\n  Rectangle(\n    this.width,this.height\n  ): assert(width&gt;0),assert(height&gt;0),area=width*height;\n}\n</code></pre>"},{"location":"s17_idioms/#copying-a-class-with-one-or-more-modified-fields","title":"copying a class with one or more modified fields","text":"Kotlin<pre><code>class Rectangle(val width:Double,val height:Double)\n{\n  fun copy(width:Double?=null, height:Double?=null) =\n    Rectangle(\n      width ?: this.width, \n      height ?: this.height\n    )  \n}\n\n// in kotlin you can simply define a data class to have \n// the copy method automatically generated\ndata class Rectangle(val width:Double,val height:Double)\n</code></pre> Dart<pre><code>class Rectangle {\n  final double width;\n  final double height;\n  Rectangle(this.width,this.height);\n\n  Rectangle copy({double? width, double? height}) =&gt;\n    Rectangle(\n      width ?? this.width, \n      height ?? this.height\n    );\n}\n</code></pre>"},{"location":"s30_CHANGE_LOG/","title":"CHANGE_LOG","text":"<ul> <li>1/10/2022 : added more idioms</li> <li>28/09/2022 : added idioms</li> </ul>"}]}